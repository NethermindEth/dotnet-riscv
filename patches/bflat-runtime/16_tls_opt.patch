From fa6e00abe9be4a451d81a29309c933435db8fe40 Mon Sep 17 00:00:00 2001
From: Adeel Mujahid <3840695+am11@users.noreply.github.com>
Date: Sat, 15 Nov 2025 22:15:48 +0200
Subject: [PATCH] Disable TLS optimization for musl riscv64 (#121662)

On linux-musl-riscv64, when corehost (dotnet) dlopen()s libcoreclr, we
get:

> \# dotnet --version
> Failed to load
/root/.dotnet/shared/Microsoft.NETCore.App/10.0.0-rtm.25564.199/libcoreclr.so,
error: Error relocating
/root/.dotnet/shared/Microsoft.NETCore.App/10.0.0-rtm.25564.199/libcoreclr.so:
Uq???&?J?N?R?V?Z? .????: initial-exec TLS resolves to dynamic definition
in
/root/.dotnet/shared/Microsoft.NETCore.App/10.0.0-rtm.25564.199/libcoreclr.so
Failed to bind to CoreCLR at
'/root/.dotnet/shared/Microsoft.NETCore.App/10.0.0-rtm.25564.199/'
Failed to create CoreCLR, HRESULT: 0x80008088

musl maintainer described the issue on this golang thread:
https://github.com/golang/go/issues/54805#issuecomment-1253972041. When
I tried
`LD_PRELOAD=/root/.dotnet/shared/Microsoft.NETCore.App/10.0.0-rtm.25564.199/libcoreclr.so
dotnet --version`, it started working and SDK started working.

By disabling the optimization as we have done for linux-musl-arm64 and
removing `la.tls.ie` from binary works without the `LD_PRELOAD` hack.

---------

Co-authored-by: Jan Kotas <jkotas@microsoft.com>
---
 src/coreclr/vm/riscv64/asmhelpers.S | 4 ++++
 src/coreclr/vm/threadstatics.cpp    | 5 +++++
 2 files changed, 9 insertions(+)

diff --git a/src/coreclr/vm/riscv64/asmhelpers.S b/src/coreclr/vm/riscv64/asmhelpers.S
index 1c03436880c0cc..e9c049f1b64197 100644
--- a/src/coreclr/vm/riscv64/asmhelpers.S
+++ b/src/coreclr/vm/riscv64/asmhelpers.S
@@ -844,10 +844,14 @@ LEAF_END JIT_PatchpointForced, _TEXT
 // size_t GetThreadStaticsVariableOffset()
 
 // Load offset of native thread local variable `t_ThreadStatics` in TCB and return it in `a0` register.
+#if !defined(TARGET_LINUX_MUSL)
+// Uses initial-exec TLS model which is faster but incompatible with musl's dynamic loading.
+// On musl, this function is not compiled and the optimization is disabled in threadstatics.cpp.
 LEAF_ENTRY GetThreadStaticsVariableOffset, _TEXT
     la.tls.ie   a0, t_ThreadStatics
     EPILOG_RETURN
 LEAF_END GetThreadStaticsVariableOffset, _TEXT
+#endif // !TARGET_LINUX_MUSL
 
 LEAF_ENTRY JIT_PollGC, _TEXT
         PREPARE_EXTERNAL_VAR g_TrapReturningThreads, t0
diff --git a/src/coreclr/vm/threadstatics.cpp b/src/coreclr/vm/threadstatics.cpp
index 5847cc5c13bb47..0f45787cd8f92b 100644
--- a/src/coreclr/vm/threadstatics.cpp
+++ b/src/coreclr/vm/threadstatics.cpp
@@ -916,6 +916,8 @@ bool CanJITOptimizeTLSAccess()
     // Optimization is disabled for linux/x86
 #elif defined(TARGET_LINUX_MUSL) && defined(TARGET_ARM64)
     // Optimization is disabled for linux musl arm64
+#elif defined(TARGET_LINUX_MUSL) && defined(TARGET_RISCV64)
+    // Optimization is disabled for linux musl riscv64
 #elif defined(TARGET_FREEBSD) && defined(TARGET_ARM64)
     // Optimization is disabled for FreeBSD/arm64
 #elif defined(TARGET_ANDROID)
@@ -1095,7 +1097,10 @@ void GetThreadLocalStaticBlocksInfo(CORINFO_THREAD_STATIC_BLOCKS_INFO* pInfo)
     // For Linux arm64/loongarch64/riscv64, just get the offset of thread static variable, and during execution,
     // this offset, arm64 taken from trpid_elp0 system register gives back the thread variable address.
     // this offset, loongarch64 taken from $tp register gives back the thread variable address.
+#if !(defined(TARGET_LINUX_MUSL) && defined(TARGET_RISCV64))
+    // On musl riscv64, this optimization is disabled due to initial-exec TLS incompatibility.
     threadStaticBaseOffset = GetThreadStaticsVariableOffset();
+#endif
 
 #else
     _ASSERTE_MSG(false, "Unsupported scenario of optimizing TLS access on Linux Arm32/x86 and Android");
